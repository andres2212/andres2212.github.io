<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASL Alphabet Detection</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.10.0/dist/ort.min.js"></script>
    <script src="https://docs.opencv.org/4.5.4/opencv.js"></script>

</head>

<body>
    <input type="file" id="inputImage" accept="image/*">
    <div>
        <img id="originalImage" src="#" alt="Original Image" style="display:none;">
        <canvas id="resultCanvas"></canvas>
    </div>
    <script>
        const classes = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
        const colors = Array.from({ length: classes.length }, () => [Math.random() * 255, Math.random() * 255, Math.random() * 255]);

        async function loadImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = event => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function resizeImage(image, targetWidth = 640, targetHeight = 640) {
            const resizedCanvas = document.createElement('canvas');
            resizedCanvas.width = targetWidth;
            resizedCanvas.height = targetHeight;

            const ctx = resizedCanvas.getContext('2d');
            ctx.drawImage(image, 0, 0, targetWidth, targetHeight);

            const resizedImageData = ctx.getImageData(0, 0, targetWidth, targetHeight);
            return resizedImageData;
        }


        async function preprocessImage(image, targetWidth = 640, targetHeight = 640) {

            // Get the <img> tag from the HTML document
            let img = document.getElementById('originalImage');

            // Create a canvas element to draw the image onto
            let canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;

            // Draw the image onto the canvas
            let ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // Convert the pixel data of the canvas to a cv.Mat object
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let matObj = cv.matFromImageData(imageData);

            // Assuming you have a Mat object named 'matObj' with 4 channels
            let mat = new cv.Mat(matObj.rows, matObj.cols, cv.CV_8UC3);
            cv.cvtColor(matObj, mat, cv.COLOR_RGBA2RGB);
            let matShape = mat.sizes;

            // Get the size of the largest side of the original image
            let largest_side = Math.max(mat.cols, mat.rows);

            // Create a new cv.Mat object filled with zeros (black color)
            let blackCanvas = new cv.Mat.zeros(largest_side, largest_side, cv.CV_8UC3);

            // Set a region of interest in the new blackCanvas
            let roi = blackCanvas.roi(new cv.Rect(0, 0, mat.cols, mat.rows));
            mat.copyTo(roi);

            const blob = cv.blobFromImage(blackCanvas, 1.0 / 255.0, new cv.Size(640, 640), new cv.Scalar(0, 0, 0), false, false, cv.CV_32F);

            // Create an ort.Tensor from the Float32Array
            const inputT = new ort.Tensor('float32', blob.data32F, [1, 3, 640, 640]);

            console.log(inputT)

            return inputT;
        }

        async function runObjectDetection(session, inputImage) {
            const [height, width] = [inputImage.height, inputImage.width];
            const length = Math.max(height, width);
            const scale = length / 640;

            const inputTensor = await preprocessImage(inputImage);
            const { output0 } = await session.run({ images: inputTensor }); // run session and get output layer

            return { output0, scale };
        }


        function drawBoundingBox(ctx, classId, confidence, x, y, xPlusW, yPlusH) {
            const label = `${classes[classId]} (${confidence.toFixed(2)})`;
            console.log(classId)
            console.log(confidence)

            const color = `rgb(${colors[classId].join(',')})`;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, xPlusW - x, yPlusH - y);
            ctx.font = '16px sans-serif';
            ctx.fillStyle = color;
            ctx.fillText(label, x - 10, y - 10);
        }
        function transpose(tensor) {
            const [batch, rows, cols] = tensor.dims;
            const transposed = new Float32Array(cols * rows);
            const data = tensor.data;

            for (let row = 0; row < rows; ++row) {
                for (let col = 0; col < cols; ++col) {
                    transposed[col * rows + row] = data[row * cols + col];
                }
            }

            return new ort.Tensor(tensor.type, transposed, [cols, rows]);
        }

        async function main(modelUrl, inputImage) {
            const session = await ort.InferenceSession.create(modelUrl);

            const originalImage = document.getElementById('originalImage');
            const canvas = document.getElementById('resultCanvas');
            const ctx = canvas.getContext('2d');

            const { output0, scale } = await runObjectDetection(session, inputImage);
            const outputData = transpose(output0);

            const rows = outputData.dims[0];

            const boxes = [];
            const scores = [];
            const classIds = [];

            for (let i = 0; i < rows; i++) {
                const rowData = outputData.data.slice(i * 30, (i + 1) * 30);
                const classScores = rowData.slice(4);

                const maxScore = Math.max(...classScores);
                const maxClassIndex = classScores.findIndex(score => score === maxScore);

                if (maxScore >= 0.25) {
                    const box = [
                        rowData[0] - (0.5 * rowData[2]), rowData[1] - (0.5 * rowData[3]),
                        rowData[2], rowData[3]
                    ];
                    boxes.push(box);
                    scores.push(maxScore);
                    classIds.push(maxClassIndex);
                }
            }

            const maxScoreIndex = scores.indexOf(Math.max(...scores));

            canvas.width = inputImage.width;
            canvas.height = inputImage.height;
            ctx.drawImage(originalImage, 0, 0);

            const box = boxes[maxScoreIndex];
            drawBoundingBox(ctx, classIds[maxScoreIndex], scores[maxScoreIndex], Math.round(box[0] * scale), Math.round(box[1] * scale),
                Math.round((box[0] + box[2]) * scale), Math.round((box[1] + box[3]) * scale));
        }



        document.getElementById('inputImage').addEventListener('change', async event => {
            const file = event.target.files[0];
            if (!file) return;

            const originalImage = document.getElementById('originalImage');
            originalImage.src = URL.createObjectURL(file);
            originalImage.onload = async () => {
                const inputImage = await loadImage(file);
                const inputCanvas = document.createElement('canvas');
                inputCanvas.width = inputImage.width;
                inputCanvas.height = inputImage.height;
                const inputCtx = inputCanvas.getContext('2d');
                inputCtx.drawImage(inputImage, 0, 0);
                const inputImageElement = new Image(inputImage.width, inputImage.height);
                inputImageElement.src = inputCanvas.toDataURL();
                // Provide the URL to your ONNX model file
                const modelUrl = 'best12.onnx';
                await main(modelUrl, inputImageElement);
            };
        });
    </script>
</body>

</html>
